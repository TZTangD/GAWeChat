{"remainingRequest":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\ng2-img-cropper\\src\\exif.js","dependencies":[{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\ng2-img-cropper\\src\\exif.js","mtime":1498555521000},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":0},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nvar Fraction = /*@__PURE__*/ (function (_super) {\r\n    __extends(Fraction, _super);\r\n    function Fraction() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Fraction;\r\n}(Number));\r\nexport { Fraction };\r\n// Console debug wrapper that makes code looks a little bit cleaner\r\nvar Debug = /*@__PURE__*/ (function () {\r\n    function Debug() {\r\n    }\r\n    Debug.log = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (Exif.debug) {\r\n            console.log(args);\r\n        }\r\n    };\r\n    return Debug;\r\n}());\r\nexport { Debug };\r\nvar Exif = /*@__PURE__*/ (function () {\r\n    function Exif() {\r\n    }\r\n    Exif.addEvent = function (element, event, handler) {\r\n        if (element.addEventListener) {\r\n            element.addEventListener(event, handler, false);\r\n        }\r\n        else {\r\n            // Hello, IE!\r\n            if (element.attachEvent) {\r\n                element.attachEvent('on' + event, handler);\r\n            }\r\n        }\r\n    };\r\n    Exif.imageHasData = function (img) {\r\n        return !!(img.exifdata);\r\n    };\r\n    Exif.base64ToArrayBuffer = function (base64) {\r\n        base64 = base64.replace(/^data:([^;]+);base64,/gmi, '');\r\n        var binary = atob(base64);\r\n        var len = binary.length;\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        for (var i = 0; i < len; i++) {\r\n            view[i] = binary.charCodeAt(i);\r\n        }\r\n        return buffer;\r\n    };\r\n    Exif.objectURLToBlob = function (url, callback) {\r\n        var http = new XMLHttpRequest();\r\n        http.open('GET', url, true);\r\n        http.responseType = 'blob';\r\n        http.onload = function () {\r\n            if (http.status === 200 || http.status === 0) {\r\n                callback(http.response);\r\n            }\r\n        };\r\n        http.send();\r\n    };\r\n    Exif.getImageData = function (img, callback) {\r\n        function handleBinaryFile(binFile) {\r\n            var data = Exif.findEXIFinJPEG(binFile);\r\n            var iptcdata = Exif.findIPTCinJPEG(binFile);\r\n            img.exifdata = data || {};\r\n            img.iptcdata = iptcdata || {};\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        if ('src' in img && img.src) {\r\n            if (/^data:/i.test(img.src)) {\r\n                var arrayBuffer = Exif.base64ToArrayBuffer(img.src);\r\n                handleBinaryFile(arrayBuffer);\r\n            }\r\n            else {\r\n                if (/^blob:/i.test(img.src)) {\r\n                    var fileReader_1 = new FileReader();\r\n                    fileReader_1.onload = function (e) {\r\n                        handleBinaryFile(e.target.result);\r\n                    };\r\n                    Exif.objectURLToBlob(img.src, function (blob) {\r\n                        fileReader_1.readAsArrayBuffer(blob);\r\n                    });\r\n                }\r\n                else {\r\n                    var http_1 = new XMLHttpRequest();\r\n                    http_1.onload = function () {\r\n                        if (http_1.status === 200 || http_1.status === 0) {\r\n                            handleBinaryFile(http_1.response);\r\n                        }\r\n                        else {\r\n                            throw 'Could not load image';\r\n                        }\r\n                    };\r\n                    http_1.open('GET', img.src, true);\r\n                    http_1.responseType = 'arraybuffer';\r\n                    http_1.send(null);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (FileReader && (img instanceof Blob || img instanceof File)) {\r\n                var fileReader = new FileReader();\r\n                fileReader.onload = function (e) {\r\n                    Debug.log('Got file of length ' + e.target.result.byteLength);\r\n                    handleBinaryFile(e.target.result);\r\n                };\r\n                fileReader.readAsArrayBuffer(img);\r\n            }\r\n        }\r\n    };\r\n    Exif.findEXIFinJPEG = function (file) {\r\n        var dataView = new DataView(file);\r\n        Debug.log('Got file of length ' + file.byteLength);\r\n        if ((dataView.getUint8(0) !== 0xFF) || (dataView.getUint8(1) !== 0xD8)) {\r\n            Debug.log('Not a valid JPEG');\r\n            return false; // not a valid jpeg\r\n        }\r\n        var offset = 2;\r\n        var length = file.byteLength;\r\n        var marker;\r\n        while (offset < length) {\r\n            if (dataView.getUint8(offset) !== 0xFF) {\r\n                Debug.log('Not a valid marker at offset ' + offset + ', found: ' + dataView.getUint8(offset));\r\n                return false; // not a valid marker, something is wrong\r\n            }\r\n            marker = dataView.getUint8(offset + 1);\r\n            Debug.log(marker);\r\n            // we could implement handling for other markers here,\r\n            // but we're only looking for 0xFFE1 for EXIF data\r\n            if (marker === 225) {\r\n                Debug.log('Found 0xFFE1 marker');\r\n                return Exif.readEXIFData(dataView, offset + 4); // , dataView.getUint16(offset + 2) - 2);\r\n                // offset += 2 + file.getShortAt(offset+2, true);\r\n            }\r\n            else {\r\n                offset += 2 + dataView.getUint16(offset + 2);\r\n            }\r\n        }\r\n    };\r\n    Exif.findIPTCinJPEG = function (file) {\r\n        var dataView = new DataView(file);\r\n        Debug.log('Got file of length ' + file.byteLength);\r\n        if ((dataView.getUint8(0) !== 0xFF) || (dataView.getUint8(1) !== 0xD8)) {\r\n            Debug.log('Not a valid JPEG');\r\n            return false; // not a valid jpeg\r\n        }\r\n        var offset = 2;\r\n        var length = file.byteLength;\r\n        var isFieldSegmentStart = function (_dataView, _offset) {\r\n            return (_dataView.getUint8(_offset) === 0x38 && _dataView.getUint8(_offset + 1) === 0x42 && _dataView.getUint8(_offset + 2) === 0x49 && _dataView.getUint8(_offset + 3) === 0x4D && _dataView.getUint8(_offset + 4) === 0x04 && _dataView.getUint8(_offset + 5) === 0x04);\r\n        };\r\n        while (offset < length) {\r\n            if (isFieldSegmentStart(dataView, offset)) {\r\n                // Get the length of the name header (which is padded to an even number of bytes)\r\n                var nameHeaderLength = dataView.getUint8(offset + 7);\r\n                if (nameHeaderLength % 2 !== 0) {\r\n                    nameHeaderLength += 1;\r\n                }\r\n                // Check for pre photoshop 6 format\r\n                if (nameHeaderLength === 0) {\r\n                    // Always 4\r\n                    nameHeaderLength = 4;\r\n                }\r\n                var startOffset = offset + 8 + nameHeaderLength;\r\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\r\n                return Exif.readIPTCData(file, startOffset, sectionLength);\r\n            }\r\n            // Not the marker, continue searching\r\n            offset++;\r\n        }\r\n    };\r\n    Exif.readIPTCData = function (file, startOffset, sectionLength) {\r\n        var dataView = new DataView(file);\r\n        var data = {};\r\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\r\n        var segmentStartPos = startOffset;\r\n        while (segmentStartPos < startOffset + sectionLength) {\r\n            if (dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos + 1) === 0x02) {\r\n                segmentType = dataView.getUint8(segmentStartPos + 2);\r\n                if (segmentType in Exif.IptcFieldMap) {\r\n                    dataSize = dataView.getInt16(segmentStartPos + 3);\r\n                    segmentSize = dataSize + 5;\r\n                    fieldName = Exif.IptcFieldMap[segmentType];\r\n                    fieldValue = Exif.getStringFromDB(dataView, segmentStartPos + 5, dataSize);\r\n                    // Check if we already stored a value with this name\r\n                    if (data.hasOwnProperty(fieldName)) {\r\n                        // Value already stored with this name, create multivalue field\r\n                        if (data[fieldName] instanceof Array) {\r\n                            data[fieldName].push(fieldValue);\r\n                        }\r\n                        else {\r\n                            data[fieldName] = [data[fieldName], fieldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        data[fieldName] = fieldValue;\r\n                    }\r\n                }\r\n            }\r\n            segmentStartPos++;\r\n        }\r\n        return data;\r\n    };\r\n    Exif.readTags = function (file, tiffStart, dirStart, strings, bigEnd) {\r\n        var entries = file.getUint16(dirStart, !bigEnd);\r\n        var tags = {};\r\n        var entryOffset;\r\n        var tag;\r\n        for (var i = 0; i < entries; i++) {\r\n            entryOffset = dirStart + i * 12 + 2;\r\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n            if (!tag) {\r\n                Debug.log('Unknown tag: ' + file.getUint16(entryOffset, !bigEnd));\r\n            }\r\n            tags[tag] = Exif.readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n        }\r\n        return tags;\r\n    };\r\n    Exif.readTagValue = function (file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n        var type = file.getUint16(entryOffset + 2, !bigEnd);\r\n        var numValues = file.getUint32(entryOffset + 4, !bigEnd);\r\n        var valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;\r\n        var offset;\r\n        var vals, val, n;\r\n        var numerator;\r\n        var denominator;\r\n        switch (type) {\r\n            case 1: // byte, 8-bit unsigned int\r\n            case 7:// undefined, 8-bit byte, value depending on field\r\n                if (numValues === 1) {\r\n                    return file.getUint8(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint8(offset + n);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 2:// ascii, 8-bit byte\r\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                return Exif.getStringFromDB(file, offset, numValues - 1);\r\n            case 3:// short, 16 bit int\r\n                if (numValues === 1) {\r\n                    return file.getUint16(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 4:// long, 32 bit int\r\n                if (numValues === 1) {\r\n                    return file.getUint32(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 5:// rational = two long values, first is numerator, second is denominator\r\n                if (numValues === 1) {\r\n                    numerator = file.getUint32(valueOffset, !bigEnd);\r\n                    denominator = file.getUint32(valueOffset + 4, !bigEnd);\r\n                    val = new Fraction(numerator / denominator);\r\n                    val.numerator = numerator;\r\n                    val.denominator = denominator;\r\n                    return val;\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\r\n                        denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\r\n                        vals[n] = new Fraction(numerator / denominator);\r\n                        vals[n].numerator = numerator;\r\n                        vals[n].denominator = denominator;\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 9:// slong, 32 bit signed int\r\n                if (numValues === 1) {\r\n                    return file.getInt32(entryOffset + 8, !bigEnd);\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            case 10:// signed rational, two slongs, first is numerator, second is denominator\r\n                if (numValues === 1) {\r\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);\r\n                }\r\n                else {\r\n                    vals = [];\r\n                    for (n = 0; n < numValues; n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n    };\r\n    Exif.getStringFromDB = function (buffer, start, length) {\r\n        var outstr = '';\r\n        for (var n = start; n < start + length; n++) {\r\n            outstr += String.fromCharCode(buffer.getUint8(n));\r\n        }\r\n        return outstr;\r\n    };\r\n    Exif.readEXIFData = function (file, start) {\r\n        if (Exif.getStringFromDB(file, start, 4) !== 'Exif') {\r\n            Debug.log('Not valid EXIF data! ' + Exif.getStringFromDB(file, start, 4));\r\n            return false;\r\n        }\r\n        var bigEnd, tags, tag, exifData, gpsData, tiffOffset = start + 6;\r\n        // test for TIFF validity and endianness\r\n        if (file.getUint16(tiffOffset) === 0x4949) {\r\n            bigEnd = false;\r\n        }\r\n        else {\r\n            if (file.getUint16(tiffOffset) === 0x4D4D) {\r\n                bigEnd = true;\r\n            }\r\n            else {\r\n                Debug.log('Not valid TIFF data! (no 0x4949 or 0x4D4D)');\r\n                return false;\r\n            }\r\n        }\r\n        if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {\r\n            Debug.log('Not valid TIFF data! (no 0x002A)');\r\n            return false;\r\n        }\r\n        var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\r\n        if (firstIFDOffset < 0x00000008) {\r\n            Debug.log('Not valid TIFF data! (First offset less than 8)', file.getUint32(tiffOffset + 4, !bigEnd));\r\n            return false;\r\n        }\r\n        tags = Exif.readTags(file, tiffOffset, tiffOffset + firstIFDOffset, Exif.TiffTags, bigEnd);\r\n        if (tags.ExifIFDPointer) {\r\n            exifData = Exif.readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, Exif.Tags, bigEnd);\r\n            for (tag in exifData) {\r\n                if ({}.hasOwnProperty.call(exifData, tag)) {\r\n                    switch (tag) {\r\n                        case 'LightSource':\r\n                        case 'Flash':\r\n                        case 'MeteringMode':\r\n                        case 'ExposureProgram':\r\n                        case 'SensingMethod':\r\n                        case 'SceneCaptureType':\r\n                        case 'SceneType':\r\n                        case 'CustomRendered':\r\n                        case 'WhiteBalance':\r\n                        case 'GainControl':\r\n                        case 'Contrast':\r\n                        case 'Saturation':\r\n                        case 'Sharpness':\r\n                        case 'SubjectDistanceRange':\r\n                        case 'FileSource':\r\n                            exifData[tag] = Exif.StringValues[tag][exifData[tag]];\r\n                            break;\r\n                        case 'ExifVersion':\r\n                        case 'FlashpixVersion':\r\n                            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\r\n                            break;\r\n                        case 'ComponentsConfiguration':\r\n                            var compopents = 'Components';\r\n                            exifData[tag] = Exif.StringValues[compopents][exifData[tag][0]] + Exif.StringValues[compopents][exifData[tag][1]] + Exif.StringValues[compopents][exifData[tag][2]] + Exif.StringValues[compopents][exifData[tag][3]];\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    tags[tag] = exifData[tag];\r\n                }\r\n            }\r\n        }\r\n        if (tags.GPSInfoIFDPointer) {\r\n            gpsData = Exif.readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, Exif.GPSTags, bigEnd);\r\n            for (tag in gpsData) {\r\n                if ({}.hasOwnProperty.call(gpsData, tag)) {\r\n                    switch (tag) {\r\n                        case 'GPSVersionID':\r\n                            gpsData[tag] = gpsData[tag][0] + '.' + gpsData[tag][1] + '.' + gpsData[tag][2] + '.' + gpsData[tag][3];\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    tags[tag] = gpsData[tag];\r\n                }\r\n            }\r\n        }\r\n        return tags;\r\n    };\r\n    Exif.getData = function (img, callback) {\r\n        if ((img instanceof Image || img instanceof HTMLImageElement) && !img.complete) {\r\n            return false;\r\n        }\r\n        if (!Exif.imageHasData(img)) {\r\n            Exif.getImageData(img, callback);\r\n        }\r\n        else {\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Exif.getTag = function (img, tag) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return;\r\n        }\r\n        return img.exifdata[tag];\r\n    };\r\n    ;\r\n    Exif.getAllTags = function (img) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return {};\r\n        }\r\n        var a, data = img.exifdata, tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    };\r\n    ;\r\n    Exif.pretty = function (img) {\r\n        if (!Exif.imageHasData(img)) {\r\n            return '';\r\n        }\r\n        var a, data = img.exifdata, strPretty = '';\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                if (typeof data[a] === 'object') {\r\n                    if (data[a] instanceof Number) {\r\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\r\n                    }\r\n                    else {\r\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\r\n                    }\r\n                }\r\n                else {\r\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n        return strPretty;\r\n    };\r\n    Exif.readFromBinaryFile = function (file) {\r\n        return Exif.findEXIFinJPEG(file);\r\n    };\r\n    Exif.debug = false;\r\n    Exif.IptcFieldMap = {\r\n        0x78: 'caption',\r\n        0x6E: 'credit',\r\n        0x19: 'keywords',\r\n        0x37: 'dateCreated',\r\n        0x50: 'byline',\r\n        0x55: 'bylineTitle',\r\n        0x7A: 'captionWriter',\r\n        0x69: 'headline',\r\n        0x74: 'copyright',\r\n        0x0F: 'category'\r\n    };\r\n    Exif.Tags = {\r\n        // version tags\r\n        0x9000: 'ExifVersion',\r\n        0xA000: 'FlashpixVersion',\r\n        // colorspace tags\r\n        0xA001: 'ColorSpace',\r\n        // image configuration\r\n        0xA002: 'PixelXDimension',\r\n        0xA003: 'PixelYDimension',\r\n        0x9101: 'ComponentsConfiguration',\r\n        0x9102: 'CompressedBitsPerPixel',\r\n        // user information\r\n        0x927C: 'MakerNote',\r\n        0x9286: 'UserComment',\r\n        // related file\r\n        0xA004: 'RelatedSoundFile',\r\n        // date and time\r\n        0x9003: 'DateTimeOriginal',\r\n        0x9004: 'DateTimeDigitized',\r\n        0x9290: 'SubsecTime',\r\n        0x9291: 'SubsecTimeOriginal',\r\n        0x9292: 'SubsecTimeDigitized',\r\n        // picture-taking conditions\r\n        0x829A: 'ExposureTime',\r\n        0x829D: 'FNumber',\r\n        0x8822: 'ExposureProgram',\r\n        0x8824: 'SpectralSensitivity',\r\n        0x8827: 'ISOSpeedRatings',\r\n        0x8828: 'OECF',\r\n        0x9201: 'ShutterSpeedValue',\r\n        0x9202: 'ApertureValue',\r\n        0x9203: 'BrightnessValue',\r\n        0x9204: 'ExposureBias',\r\n        0x9205: 'MaxApertureValue',\r\n        0x9206: 'SubjectDistance',\r\n        0x9207: 'MeteringMode',\r\n        0x9208: 'LightSource',\r\n        0x9209: 'Flash',\r\n        0x9214: 'SubjectArea',\r\n        0x920A: 'FocalLength',\r\n        0xA20B: 'FlashEnergy',\r\n        0xA20C: 'SpatialFrequencyResponse',\r\n        0xA20E: 'FocalPlaneXResolution',\r\n        0xA20F: 'FocalPlaneYResolution',\r\n        0xA210: 'FocalPlaneResolutionUnit',\r\n        0xA214: 'SubjectLocation',\r\n        0xA215: 'ExposureIndex',\r\n        0xA217: 'SensingMethod',\r\n        0xA300: 'FileSource',\r\n        0xA301: 'SceneType',\r\n        0xA302: 'CFAPattern',\r\n        0xA401: 'CustomRendered',\r\n        0xA402: 'ExposureMode',\r\n        0xA403: 'WhiteBalance',\r\n        0xA404: 'DigitalZoomRation',\r\n        0xA405: 'FocalLengthIn35mmFilm',\r\n        0xA406: 'SceneCaptureType',\r\n        0xA407: 'GainControl',\r\n        0xA408: 'Contrast',\r\n        0xA409: 'Saturation',\r\n        0xA40A: 'Sharpness',\r\n        0xA40B: 'DeviceSettingDescription',\r\n        0xA40C: 'SubjectDistanceRange',\r\n        // other tags\r\n        0xA005: 'InteroperabilityIFDPointer', 0xA420: 'ImageUniqueID' // Identifier assigned uniquely to each image\r\n    };\r\n    Exif.TiffTags = {\r\n        0x0100: 'ImageWidth',\r\n        0x0101: 'ImageHeight',\r\n        0x8769: 'ExifIFDPointer',\r\n        0x8825: 'GPSInfoIFDPointer',\r\n        0xA005: 'InteroperabilityIFDPointer',\r\n        0x0102: 'BitsPerSample',\r\n        0x0103: 'Compression',\r\n        0x0106: 'PhotometricInterpretation',\r\n        0x0112: 'Orientation',\r\n        0x0115: 'SamplesPerPixel',\r\n        0x011C: 'PlanarConfiguration',\r\n        0x0212: 'YCbCrSubSampling',\r\n        0x0213: 'YCbCrPositioning',\r\n        0x011A: 'XResolution',\r\n        0x011B: 'YResolution',\r\n        0x0128: 'ResolutionUnit',\r\n        0x0111: 'StripOffsets',\r\n        0x0116: 'RowsPerStrip',\r\n        0x0117: 'StripByteCounts',\r\n        0x0201: 'JPEGInterchangeFormat',\r\n        0x0202: 'JPEGInterchangeFormatLength',\r\n        0x012D: 'TransferFunction',\r\n        0x013E: 'WhitePoint',\r\n        0x013F: 'PrimaryChromaticities',\r\n        0x0211: 'YCbCrCoefficients',\r\n        0x0214: 'ReferenceBlackWhite',\r\n        0x0132: 'DateTime',\r\n        0x010E: 'ImageDescription',\r\n        0x010F: 'Make',\r\n        0x0110: 'Model',\r\n        0x0131: 'Software',\r\n        0x013B: 'Artist',\r\n        0x8298: 'Copyright'\r\n    };\r\n    Exif.GPSTags = {\r\n        0x0000: 'GPSVersionID',\r\n        0x0001: 'GPSLatitudeRef',\r\n        0x0002: 'GPSLatitude',\r\n        0x0003: 'GPSLongitudeRef',\r\n        0x0004: 'GPSLongitude',\r\n        0x0005: 'GPSAltitudeRef',\r\n        0x0006: 'GPSAltitude',\r\n        0x0007: 'GPSTimeStamp',\r\n        0x0008: 'GPSSatellites',\r\n        0x0009: 'GPSStatus',\r\n        0x000A: 'GPSMeasureMode',\r\n        0x000B: 'GPSDOP',\r\n        0x000C: 'GPSSpeedRef',\r\n        0x000D: 'GPSSpeed',\r\n        0x000E: 'GPSTrackRef',\r\n        0x000F: 'GPSTrack',\r\n        0x0010: 'GPSImgDirectionRef',\r\n        0x0011: 'GPSImgDirection',\r\n        0x0012: 'GPSMapDatum',\r\n        0x0013: 'GPSDestLatitudeRef',\r\n        0x0014: 'GPSDestLatitude',\r\n        0x0015: 'GPSDestLongitudeRef',\r\n        0x0016: 'GPSDestLongitude',\r\n        0x0017: 'GPSDestBearingRef',\r\n        0x0018: 'GPSDestBearing',\r\n        0x0019: 'GPSDestDistanceRef',\r\n        0x001A: 'GPSDestDistance',\r\n        0x001B: 'GPSProcessingMethod',\r\n        0x001C: 'GPSAreaInformation',\r\n        0x001D: 'GPSDateStamp',\r\n        0x001E: 'GPSDifferential'\r\n    };\r\n    Exif.StringValues = {\r\n        ExposureProgram: {\r\n            0: 'Not defined',\r\n            1: 'Manual',\r\n            2: 'Normal program',\r\n            3: 'Aperture priority',\r\n            4: 'Shutter priority',\r\n            5: 'Creative program',\r\n            6: 'Action program',\r\n            7: 'Portrait mode',\r\n            8: 'Landscape mode'\r\n        }, MeteringMode: {\r\n            0: 'Unknown',\r\n            1: 'Average',\r\n            2: 'CenterWeightedAverage',\r\n            3: 'Spot',\r\n            4: 'MultiSpot',\r\n            5: 'Pattern',\r\n            6: 'Partial',\r\n            255: 'Other'\r\n        }, LightSource: {\r\n            0: 'Unknown',\r\n            1: 'Daylight',\r\n            2: 'Fluorescent',\r\n            3: 'Tungsten (incandescent light)',\r\n            4: 'Flash',\r\n            9: 'Fine weather',\r\n            10: 'Cloudy weather',\r\n            11: 'Shade',\r\n            12: 'Daylight fluorescent (D 5700 - 7100K)',\r\n            13: 'Day white fluorescent (N 4600 - 5400K)',\r\n            14: 'Cool white fluorescent (W 3900 - 4500K)',\r\n            15: 'White fluorescent (WW 3200 - 3700K)',\r\n            17: 'Standard light A',\r\n            18: 'Standard light B',\r\n            19: 'Standard light C',\r\n            20: 'D55',\r\n            21: 'D65',\r\n            22: 'D75',\r\n            23: 'D50',\r\n            24: 'ISO studio tungsten',\r\n            255: 'Other'\r\n        }, Flash: {\r\n            0x0000: 'Flash did not fire',\r\n            0x0001: 'Flash fired',\r\n            0x0005: 'Strobe return light not detected',\r\n            0x0007: 'Strobe return light detected',\r\n            0x0009: 'Flash fired, compulsory flash mode',\r\n            0x000D: 'Flash fired, compulsory flash mode, return light not detected',\r\n            0x000F: 'Flash fired, compulsory flash mode, return light detected',\r\n            0x0010: 'Flash did not fire, compulsory flash mode',\r\n            0x0018: 'Flash did not fire, auto mode',\r\n            0x0019: 'Flash fired, auto mode',\r\n            0x001D: 'Flash fired, auto mode, return light not detected',\r\n            0x001F: 'Flash fired, auto mode, return light detected',\r\n            0x0020: 'No flash function',\r\n            0x0041: 'Flash fired, red-eye reduction mode',\r\n            0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\r\n            0x0047: 'Flash fired, red-eye reduction mode, return light detected',\r\n            0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\r\n            0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\r\n            0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\r\n            0x0059: 'Flash fired, auto mode, red-eye reduction mode',\r\n            0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\r\n            0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\r\n        }, SensingMethod: {\r\n            1: 'Not defined',\r\n            2: 'One-chip color area sensor',\r\n            3: 'Two-chip color area sensor',\r\n            4: 'Three-chip color area sensor',\r\n            5: 'Color sequential area sensor',\r\n            7: 'Trilinear sensor',\r\n            8: 'Color sequential linear sensor'\r\n        }, SceneCaptureType: {\r\n            0: 'Standard', 1: 'Landscape', 2: 'Portrait', 3: 'Night scene'\r\n        }, SceneType: {\r\n            1: 'Directly photographed'\r\n        }, CustomRendered: {\r\n            0: 'Normal process', 1: 'Custom process'\r\n        }, WhiteBalance: {\r\n            0: 'Auto white balance', 1: 'Manual white balance'\r\n        }, GainControl: {\r\n            0: 'None', 1: 'Low gain up', 2: 'High gain up', 3: 'Low gain down', 4: 'High gain down'\r\n        }, Contrast: {\r\n            0: 'Normal', 1: 'Soft', 2: 'Hard'\r\n        }, Saturation: {\r\n            0: 'Normal', 1: 'Low saturation', 2: 'High saturation'\r\n        }, Sharpness: {\r\n            0: 'Normal', 1: 'Soft', 2: 'Hard'\r\n        }, SubjectDistanceRange: {\r\n            0: 'Unknown', 1: 'Macro', 2: 'Close view', 3: 'Distant view'\r\n        }, FileSource: {\r\n            3: 'DSC'\r\n        },\r\n        Components: {\r\n            0: '', 1: 'Y', 2: 'Cb', 3: 'Cr', 4: 'R', 5: 'G', 6: 'B'\r\n        }\r\n    };\r\n    return Exif;\r\n}());\r\nexport { Exif };\r\n//# sourceMappingURL=exif.js.map \r\n",null]}