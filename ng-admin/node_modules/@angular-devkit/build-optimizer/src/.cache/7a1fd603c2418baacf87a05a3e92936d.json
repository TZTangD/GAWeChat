{"remainingRequest":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\ng2-img-cropper\\src\\imageCropper.js","dependencies":[{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\ng2-img-cropper\\src\\imageCropper.js","mtime":1498555521000},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":0},{"path":"D:\\mygit\\HCWeChat\\ng-admin\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Bounds } from './model/bounds';\r\nimport { CornerMarker } from './model/cornerMarker';\r\nimport { CropTouch } from './model/cropTouch';\r\nimport { DragMarker } from './model/dragMarker';\r\nimport { ImageCropperModel } from './model/imageCropperModel';\r\nimport { ImageCropperDataShare } from './imageCropperDataShare';\r\nimport { PointPool } from './model/pointPool';\r\nvar ImageCropper = /*@__PURE__*/ (function (_super) {\r\n    __extends(ImageCropper, _super);\r\n    function ImageCropper(cropperSettings) {\r\n        var _this = _super.call(this) || this;\r\n        var x = 0;\r\n        var y = 0;\r\n        var width = cropperSettings.width;\r\n        var height = cropperSettings.height;\r\n        var keepAspect = cropperSettings.keepAspect;\r\n        var touchRadius = cropperSettings.touchRadius;\r\n        var minWidth = cropperSettings.minWidth;\r\n        var minHeight = cropperSettings.minHeight;\r\n        var croppedWidth = cropperSettings.croppedWidth;\r\n        var croppedHeight = cropperSettings.croppedHeight;\r\n        _this.cropperSettings = cropperSettings;\r\n        _this.crop = _this;\r\n        _this.x = x;\r\n        _this.y = y;\r\n        if (width === void 0) {\r\n            _this.width = 100;\r\n        }\r\n        if (height === void 0) {\r\n            _this.height = 50;\r\n        }\r\n        if (keepAspect === void 0) {\r\n            _this.keepAspect = true;\r\n        }\r\n        if (touchRadius === void 0) {\r\n            _this.touchRadius = 20;\r\n        }\r\n        _this.minWidth = minWidth;\r\n        _this.minHeight = minHeight;\r\n        _this.keepAspect = false;\r\n        _this.aspectRatio = 0;\r\n        _this.currentDragTouches = [];\r\n        _this.isMouseDown = false;\r\n        _this.ratioW = 1;\r\n        _this.ratioH = 1;\r\n        _this.fileType = cropperSettings.fileType;\r\n        _this.imageSet = false;\r\n        _this.pointPool = new PointPool(200);\r\n        _this.tl = new CornerMarker(x, y, touchRadius, _this.cropperSettings);\r\n        _this.tr = new CornerMarker(x + width, y, touchRadius, _this.cropperSettings);\r\n        _this.bl = new CornerMarker(x, y + height, touchRadius, _this.cropperSettings);\r\n        _this.br = new CornerMarker(x + width, y + height, touchRadius, _this.cropperSettings);\r\n        _this.tl.addHorizontalNeighbour(_this.tr);\r\n        _this.tl.addVerticalNeighbour(_this.bl);\r\n        _this.tr.addHorizontalNeighbour(_this.tl);\r\n        _this.tr.addVerticalNeighbour(_this.br);\r\n        _this.bl.addHorizontalNeighbour(_this.br);\r\n        _this.bl.addVerticalNeighbour(_this.tl);\r\n        _this.br.addHorizontalNeighbour(_this.bl);\r\n        _this.br.addVerticalNeighbour(_this.tr);\r\n        _this.markers = [_this.tl, _this.tr, _this.bl, _this.br];\r\n        _this.center = new DragMarker(x + (width / 2), y + (height / 2), touchRadius, _this.cropperSettings);\r\n        _this.keepAspect = keepAspect;\r\n        _this.aspectRatio = height / width;\r\n        _this.croppedImage = new Image();\r\n        _this.currentlyInteracting = false;\r\n        _this.cropWidth = croppedWidth;\r\n        _this.cropHeight = croppedHeight;\r\n        return _this;\r\n    }\r\n    ImageCropper.sign = function (x) {\r\n        if (+x === x) {\r\n            return (x === 0) ? x : (x > 0) ? 1 : -1;\r\n        }\r\n        return NaN;\r\n    };\r\n    ImageCropper.getMousePos = function (canvas, evt) {\r\n        var rect = canvas.getBoundingClientRect();\r\n        return PointPool.instance.borrow(evt.clientX - rect.left, evt.clientY - rect.top);\r\n    };\r\n    ImageCropper.getTouchPos = function (canvas, touch) {\r\n        var rect = canvas.getBoundingClientRect();\r\n        return PointPool.instance.borrow(touch.clientX - rect.left, touch.clientY - rect.top);\r\n    };\r\n    ImageCropper.detectVerticalSquash = function (img) {\r\n        var ih = img.height;\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = 1;\r\n        canvas.height = ih;\r\n        var ctx = canvas.getContext('2d');\r\n        ctx.drawImage(img, 0, 0);\r\n        var imageData = ctx.getImageData(0, 0, 1, ih);\r\n        if (imageData) {\r\n            var data = imageData.data;\r\n            // search image edge pixel position in case it is squashed vertically.\r\n            var sy = 0;\r\n            var ey = ih;\r\n            var py = ih;\r\n            while (py > sy) {\r\n                var alpha = data[(py - 1) * 4 + 3];\r\n                if (alpha === 0) {\r\n                    ey = py;\r\n                }\r\n                else {\r\n                    sy = py;\r\n                }\r\n                py = (ey + sy) >> 1;\r\n            }\r\n            var ratio = (py / ih);\r\n            return (ratio === 0) ? 1 : ratio;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    };\r\n    ImageCropper.prototype.getDataUriMimeType = function (dataUri) {\r\n        // Get a substring because the regex does not perform well on very large strings. Cater for optional charset. Length 50 shoould be enough.\r\n        var dataUriSubstring = dataUri.substring(0, 50);\r\n        var mimeType = 'image/png';\r\n        // data-uri scheme\r\n        // data:[<media type>][;charset=<character set>][;base64],<data>\r\n        var regEx = RegExp(/^(data:)([\\w\\/\\+]+);(charset=[\\w-]+|base64).*,(.*)/gi);\r\n        var matches = regEx.exec(dataUriSubstring);\r\n        if (matches && matches[2]) {\r\n            mimeType = matches[2];\r\n            if (mimeType == 'image/jpg') {\r\n                mimeType = 'image/jpeg';\r\n            }\r\n        }\r\n        return mimeType;\r\n    };\r\n    ImageCropper.prototype.prepare = function (canvas) {\r\n        this.buffer = document.createElement('canvas');\r\n        this.cropCanvas = document.createElement('canvas');\r\n        // todo get more reliable parent width value.\r\n        var responsiveWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0;\r\n        if (responsiveWidth > 0 && this.cropperSettings.dynamicSizing) {\r\n            this.cropCanvas.width = responsiveWidth;\r\n            this.buffer.width = responsiveWidth;\r\n            canvas.width = responsiveWidth;\r\n        }\r\n        else {\r\n            this.cropCanvas.width = this.cropWidth;\r\n            this.buffer.width = canvas.width;\r\n        }\r\n        this.cropCanvas.height = this.cropHeight;\r\n        this.buffer.height = canvas.height;\r\n        this.canvas = canvas;\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.draw(this.ctx);\r\n    };\r\n    ImageCropper.prototype.resizeCanvas = function (width, height, setImage) {\r\n        if (setImage === void 0) {\r\n            setImage = false;\r\n        }\r\n        this.canvas.width = this.cropCanvas.width = this.width = this.canvasWidth = this.buffer.width = width;\r\n        this.canvas.height = this.cropCanvas.height = this.height = this.canvasHeight = this.buffer.height = height;\r\n        if (setImage) {\r\n            this.setImage(this.srcImage);\r\n        }\r\n    };\r\n    ImageCropper.prototype.reset = function () {\r\n        this.setImage(undefined);\r\n    };\r\n    ImageCropper.prototype.draw = function (ctx) {\r\n        var bounds = this.getBounds();\r\n        if (this.srcImage) {\r\n            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n            var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n            var canvasAspect = this.canvasHeight / this.canvasWidth;\r\n            var w = this.canvasWidth;\r\n            var h = this.canvasHeight;\r\n            if (canvasAspect > sourceAspect) {\r\n                w = this.canvasWidth;\r\n                h = this.canvasWidth * sourceAspect;\r\n            }\r\n            else {\r\n                h = this.canvasHeight;\r\n                w = this.canvasHeight / sourceAspect;\r\n            }\r\n            this.ratioW = w / this.srcImage.width;\r\n            this.ratioH = h / this.srcImage.height;\r\n            if (canvasAspect < sourceAspect) {\r\n                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, this.buffer.width / 2 - w / 2, 0, w, h);\r\n            }\r\n            else {\r\n                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, 0, this.buffer.height / 2 - h / 2, w, h);\r\n            }\r\n            this.buffer.getContext('2d')\r\n                .drawImage(this.canvas, 0, 0, this.canvasWidth, this.canvasHeight);\r\n            ctx.lineWidth = this.cropperSettings.cropperDrawSettings.strokeWidth;\r\n            ctx.strokeStyle = this.cropperSettings.cropperDrawSettings.strokeColor; // 'rgba(255,228,0,1)';\r\n            if (!this.cropperSettings.rounded) {\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n                ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n                ctx.drawImage(this.buffer, bounds.left, bounds.top, Math.max(bounds.width, 1), Math.max(bounds.height, 1), bounds.left, bounds.top, bounds.width, bounds.height);\r\n                ctx.strokeRect(bounds.left, bounds.top, bounds.width, bounds.height);\r\n            }\r\n            else {\r\n                ctx.beginPath();\r\n                ctx.arc(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2, bounds.width / 2, 0, Math.PI * 2, true);\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            }\r\n            var marker = void 0;\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                marker = this.markers[i];\r\n                marker.draw(ctx);\r\n            }\r\n            this.center.draw(ctx);\r\n        }\r\n        else {\r\n            ctx.fillStyle = 'rgba(192,192,192,1)';\r\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        }\r\n    };\r\n    ImageCropper.prototype.dragCenter = function (x, y, marker) {\r\n        var bounds = this.getBounds();\r\n        var left = x - (bounds.width / 2);\r\n        var right = x + (bounds.width / 2);\r\n        var top = y - (bounds.height / 2);\r\n        var bottom = y + (bounds.height / 2);\r\n        if (right >= this.maxXClamp) {\r\n            x = this.maxXClamp - bounds.width / 2;\r\n        }\r\n        if (left <= this.minXClamp) {\r\n            x = bounds.width / 2 + this.minXClamp;\r\n        }\r\n        if (top < this.minYClamp) {\r\n            y = bounds.height / 2 + this.minYClamp;\r\n        }\r\n        if (bottom >= this.maxYClamp) {\r\n            y = this.maxYClamp - bounds.height / 2;\r\n        }\r\n        this.tl.moveX(x - (bounds.width / 2));\r\n        this.tl.moveY(y - (bounds.height / 2));\r\n        this.tr.moveX(x + (bounds.width / 2));\r\n        this.tr.moveY(y - (bounds.height / 2));\r\n        this.bl.moveX(x - (bounds.width / 2));\r\n        this.bl.moveY(y + (bounds.height / 2));\r\n        this.br.moveX(x + (bounds.width / 2));\r\n        this.br.moveY(y + (bounds.height / 2));\r\n        marker.setPosition(x, y);\r\n    };\r\n    ImageCropper.prototype.enforceMinSize = function (x, y, marker) {\r\n        var xLength = x - marker.getHorizontalNeighbour().position.x;\r\n        var yLength = y - marker.getVerticalNeighbour().position.y;\r\n        var xOver = this.minWidth - Math.abs(xLength);\r\n        var yOver = this.minHeight - Math.abs(yLength);\r\n        if (xLength === 0 || yLength === 0) {\r\n            x = marker.position.x;\r\n            y = marker.position.y;\r\n            return PointPool.instance.borrow(x, y);\r\n        }\r\n        if (this.keepAspect) {\r\n            if (xOver > 0 && (yOver / this.aspectRatio) > 0) {\r\n                if (xOver > (yOver / this.aspectRatio)) {\r\n                    if (xLength < 0) {\r\n                        x -= xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        x += xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (yLength < 0) {\r\n                        y -= yOver;\r\n                        if (xLength < 0) {\r\n                            x -= yOver / this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            x += yOver / this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        y += yOver;\r\n                        if (xLength < 0) {\r\n                            x -= yOver / this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            x += yOver / this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (xOver > 0) {\r\n                    if (xLength < 0) {\r\n                        x -= xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                    else {\r\n                        x += xOver;\r\n                        if (yLength < 0) {\r\n                            y -= xOver * this.aspectRatio;\r\n                        }\r\n                        else {\r\n                            y += xOver * this.aspectRatio;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (yOver > 0) {\r\n                        if (yLength < 0) {\r\n                            y -= yOver;\r\n                            if (xLength < 0) {\r\n                                x -= yOver / this.aspectRatio;\r\n                            }\r\n                            else {\r\n                                x += yOver / this.aspectRatio;\r\n                            }\r\n                        }\r\n                        else {\r\n                            y += yOver;\r\n                            if (xLength < 0) {\r\n                                x -= yOver / this.aspectRatio;\r\n                            }\r\n                            else {\r\n                                x += yOver / this.aspectRatio;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (xOver > 0) {\r\n                if (xLength < 0) {\r\n                    x -= xOver;\r\n                }\r\n                else {\r\n                    x += xOver;\r\n                }\r\n            }\r\n            if (yOver > 0) {\r\n                if (yLength < 0) {\r\n                    y -= yOver;\r\n                }\r\n                else {\r\n                    y += yOver;\r\n                }\r\n            }\r\n        }\r\n        if (x < this.minXClamp || x > this.maxXClamp || y < this.minYClamp || y > this.maxYClamp) {\r\n            x = marker.position.x;\r\n            y = marker.position.y;\r\n        }\r\n        return PointPool.instance.borrow(x, y);\r\n    };\r\n    ImageCropper.prototype.dragCorner = function (x, y, marker) {\r\n        var iX = 0;\r\n        var iY = 0;\r\n        var ax = 0;\r\n        var ay = 0;\r\n        var newHeight = 0;\r\n        var newWidth = 0;\r\n        var newY = 0;\r\n        var newX = 0;\r\n        var anchorMarker;\r\n        var fold = 0;\r\n        if (this.keepAspect) {\r\n            anchorMarker = marker.getHorizontalNeighbour().getVerticalNeighbour();\r\n            ax = anchorMarker.position.x;\r\n            ay = anchorMarker.position.y;\r\n            if (x <= anchorMarker.position.x) {\r\n                if (y <= anchorMarker.position.y) {\r\n                    iX = ax - (100 / this.aspectRatio);\r\n                    iY = ay - (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold > 0) {\r\n                        newHeight = Math.abs(anchorMarker.position.y - y);\r\n                        newWidth = newHeight / this.aspectRatio;\r\n                        newY = anchorMarker.position.y - newHeight;\r\n                        newX = anchorMarker.position.x - newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold < 0) {\r\n                            newWidth = Math.abs(anchorMarker.position.x - x);\r\n                            newHeight = newWidth * this.aspectRatio;\r\n                            newY = anchorMarker.position.y - newHeight;\r\n                            newX = anchorMarker.position.x - newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    iX = ax - (100 / this.aspectRatio);\r\n                    iY = ay + (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold > 0) {\r\n                        newWidth = Math.abs(anchorMarker.position.x - x);\r\n                        newHeight = newWidth * this.aspectRatio;\r\n                        newY = anchorMarker.position.y + newHeight;\r\n                        newX = anchorMarker.position.x - newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold < 0) {\r\n                            newHeight = Math.abs(anchorMarker.position.y - y);\r\n                            newWidth = newHeight / this.aspectRatio;\r\n                            newY = anchorMarker.position.y + newHeight;\r\n                            newX = anchorMarker.position.x - newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (y <= anchorMarker.position.y) {\r\n                    iX = ax + (100 / this.aspectRatio);\r\n                    iY = ay - (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold < 0) {\r\n                        newHeight = Math.abs(anchorMarker.position.y - y);\r\n                        newWidth = newHeight / this.aspectRatio;\r\n                        newY = anchorMarker.position.y - newHeight;\r\n                        newX = anchorMarker.position.x + newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold > 0) {\r\n                            newWidth = Math.abs(anchorMarker.position.x - x);\r\n                            newHeight = newWidth * this.aspectRatio;\r\n                            newY = anchorMarker.position.y - newHeight;\r\n                            newX = anchorMarker.position.x + newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    iX = ax + (100 / this.aspectRatio);\r\n                    iY = ay + (100 / this.aspectRatio * this.aspectRatio);\r\n                    fold = this.getSide(PointPool.instance.borrow(iX, iY), anchorMarker.position, PointPool.instance.borrow(x, y));\r\n                    if (fold < 0) {\r\n                        newWidth = Math.abs(anchorMarker.position.x - x);\r\n                        newHeight = newWidth * this.aspectRatio;\r\n                        newY = anchorMarker.position.y + newHeight;\r\n                        newX = anchorMarker.position.x + newWidth;\r\n                        var min = this.enforceMinSize(newX, newY, marker);\r\n                        marker.move(min.x, min.y);\r\n                        PointPool.instance.returnPoint(min);\r\n                    }\r\n                    else {\r\n                        if (fold > 0) {\r\n                            newHeight = Math.abs(anchorMarker.position.y - y);\r\n                            newWidth = newHeight / this.aspectRatio;\r\n                            newY = anchorMarker.position.y + newHeight;\r\n                            newX = anchorMarker.position.x + newWidth;\r\n                            var min = this.enforceMinSize(newX, newY, marker);\r\n                            marker.move(min.x, min.y);\r\n                            PointPool.instance.returnPoint(min);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var min = this.enforceMinSize(x, y, marker);\r\n            marker.move(min.x, min.y);\r\n            PointPool.instance.returnPoint(min);\r\n        }\r\n        this.center.recalculatePosition(this.getBounds());\r\n    };\r\n    ImageCropper.prototype.getSide = function (a, b, c) {\r\n        var n = ImageCropper.sign((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\r\n        // TODO move the return of the pools to outside of this function\r\n        PointPool.instance.returnPoint(a);\r\n        PointPool.instance.returnPoint(c);\r\n        return n;\r\n    };\r\n    ImageCropper.prototype.handleRelease = function (newCropTouch) {\r\n        if (newCropTouch == null) {\r\n            return;\r\n        }\r\n        var index = 0;\r\n        for (var k = 0; k < this.currentDragTouches.length; k++) {\r\n            if (newCropTouch.id === this.currentDragTouches[k].id) {\r\n                this.currentDragTouches[k].dragHandle.setDrag(false);\r\n                index = k;\r\n            }\r\n        }\r\n        this.currentDragTouches.splice(index, 1);\r\n        this.draw(this.ctx);\r\n    };\r\n    ImageCropper.prototype.handleMove = function (newCropTouch) {\r\n        var matched = false;\r\n        for (var k = 0; k < this.currentDragTouches.length; k++) {\r\n            if (newCropTouch.id === this.currentDragTouches[k].id && this.currentDragTouches[k].dragHandle != null) {\r\n                var dragTouch = this.currentDragTouches[k];\r\n                var clampedPositions = this.clampPosition(newCropTouch.x - dragTouch.dragHandle.offset.x, newCropTouch.y - dragTouch.dragHandle.offset.y);\r\n                newCropTouch.x = clampedPositions.x;\r\n                newCropTouch.y = clampedPositions.y;\r\n                PointPool.instance.returnPoint(clampedPositions);\r\n                if (dragTouch.dragHandle instanceof CornerMarker) {\r\n                    this.dragCorner(newCropTouch.x, newCropTouch.y, dragTouch.dragHandle);\r\n                }\r\n                else {\r\n                    this.dragCenter(newCropTouch.x, newCropTouch.y, dragTouch.dragHandle);\r\n                }\r\n                this.currentlyInteracting = true;\r\n                matched = true;\r\n                ImageCropperDataShare.setPressed(this.canvas);\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                var marker = this.markers[i];\r\n                if (marker.touchInBounds(newCropTouch.x, newCropTouch.y)) {\r\n                    newCropTouch.dragHandle = marker;\r\n                    this.currentDragTouches.push(newCropTouch);\r\n                    marker.setDrag(true);\r\n                    newCropTouch.dragHandle.offset.x = newCropTouch.x - newCropTouch.dragHandle.position.x;\r\n                    newCropTouch.dragHandle.offset.y = newCropTouch.y - newCropTouch.dragHandle.position.y;\r\n                    this.dragCorner(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, newCropTouch.dragHandle);\r\n                    break;\r\n                }\r\n            }\r\n            if (newCropTouch.dragHandle === null || typeof newCropTouch.dragHandle === 'undefined') {\r\n                if (this.center.touchInBounds(newCropTouch.x, newCropTouch.y)) {\r\n                    newCropTouch.dragHandle = this.center;\r\n                    this.currentDragTouches.push(newCropTouch);\r\n                    newCropTouch.dragHandle.setDrag(true);\r\n                    newCropTouch.dragHandle.offset.x = newCropTouch.x - newCropTouch.dragHandle.position.x;\r\n                    newCropTouch.dragHandle.offset.y = newCropTouch.y - newCropTouch.dragHandle.position.y;\r\n                    this.dragCenter(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, newCropTouch.dragHandle);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    ImageCropper.prototype.updateClampBounds = function () {\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        var canvasAspect = this.canvas.height / this.canvas.width;\r\n        var w = this.canvas.width;\r\n        var h = this.canvas.height;\r\n        if (canvasAspect > sourceAspect) {\r\n            w = this.canvas.width;\r\n            h = this.canvas.width * sourceAspect;\r\n        }\r\n        else {\r\n            h = this.canvas.height;\r\n            w = this.canvas.height / sourceAspect;\r\n        }\r\n        this.minXClamp = this.canvas.width / 2 - w / 2;\r\n        this.minYClamp = this.canvas.height / 2 - h / 2;\r\n        this.maxXClamp = this.canvas.width / 2 + w / 2;\r\n        this.maxYClamp = this.canvas.height / 2 + h / 2;\r\n    };\r\n    ImageCropper.prototype.getCropBounds = function () {\r\n        var bounds = this.getBounds();\r\n        bounds.top = Math.round((bounds.top - this.minYClamp) / this.ratioH);\r\n        bounds.bottom = Math.round((bounds.bottom - this.minYClamp) / this.ratioH);\r\n        bounds.left = Math.round((bounds.left - this.minXClamp) / this.ratioW);\r\n        bounds.right = Math.round((bounds.right - this.minXClamp) / this.ratioW);\r\n        return bounds;\r\n    };\r\n    ImageCropper.prototype.clampPosition = function (x, y) {\r\n        if (x < this.minXClamp) {\r\n            x = this.minXClamp;\r\n        }\r\n        if (x > this.maxXClamp) {\r\n            x = this.maxXClamp;\r\n        }\r\n        if (y < this.minYClamp) {\r\n            y = this.minYClamp;\r\n        }\r\n        if (y > this.maxYClamp) {\r\n            y = this.maxYClamp;\r\n        }\r\n        return PointPool.instance.borrow(x, y);\r\n    };\r\n    ImageCropper.prototype.isImageSet = function () {\r\n        return this.imageSet;\r\n    };\r\n    ImageCropper.prototype.setImage = function (img) {\r\n        this.srcImage = img;\r\n        if (!img) {\r\n            this.imageSet = false;\r\n            this.draw(this.ctx);\r\n        }\r\n        else {\r\n            this.imageSet = true;\r\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n            var bufferContext = this.buffer.getContext('2d');\r\n            bufferContext.clearRect(0, 0, this.buffer.width, this.buffer.height);\r\n            if (!this.cropperSettings.fileType)\r\n                this.fileType = this.getDataUriMimeType(img.src);\r\n            if (this.cropperSettings.minWithRelativeToResolution) {\r\n                this.minWidth = (this.canvas.width * this.cropperSettings.minWidth / this.srcImage.width);\r\n                this.minHeight = (this.canvas.height * this.cropperSettings.minHeight / this.srcImage.height);\r\n            }\r\n            this.updateClampBounds();\r\n            this.canvasWidth = this.canvas.width;\r\n            this.canvasHeight = this.canvas.height;\r\n            var cropPosition = this.getCropPositionFromMarkers();\r\n            this.setCropPosition(cropPosition);\r\n        }\r\n    };\r\n    ImageCropper.prototype.updateCropPosition = function (cropBounds) {\r\n        var cropPosition = this.getCropPositionFromBounds(cropBounds);\r\n        this.setCropPosition(cropPosition);\r\n    };\r\n    ImageCropper.prototype.setCropPosition = function (cropPosition) {\r\n        this.tl.setPosition(cropPosition[0].x, cropPosition[0].y);\r\n        this.tr.setPosition(cropPosition[1].x, cropPosition[1].y);\r\n        this.bl.setPosition(cropPosition[2].x, cropPosition[2].y);\r\n        this.br.setPosition(cropPosition[3].x, cropPosition[3].y);\r\n        this.center.setPosition(cropPosition[4].x, cropPosition[4].y);\r\n        for (var _i = 0, cropPosition_1 = cropPosition; _i < cropPosition_1.length; _i++) {\r\n            var position = cropPosition_1[_i];\r\n            PointPool.instance.returnPoint(position);\r\n        }\r\n        this.vertSquashRatio = ImageCropper.detectVerticalSquash(this.srcImage);\r\n        this.draw(this.ctx);\r\n        this.croppedImage = this.getCroppedImageHelper(false, this.cropWidth, this.cropHeight);\r\n    };\r\n    ImageCropper.prototype.getCropPositionFromMarkers = function () {\r\n        var w = this.canvas.width;\r\n        var h = this.canvas.height;\r\n        var tlPos, trPos, blPos, brPos, center;\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        var cropBounds = this.getBounds();\r\n        var cropAspect = cropBounds.height / cropBounds.width;\r\n        var cX = this.canvas.width / 2;\r\n        var cY = this.canvas.height / 2;\r\n        if (cropAspect > sourceAspect) {\r\n            var imageH = Math.min(w * sourceAspect, h);\r\n            var cropW = imageH / cropAspect;\r\n            tlPos = PointPool.instance.borrow(cX - cropW / 2, cY + imageH / 2);\r\n            trPos = PointPool.instance.borrow(cX + cropW / 2, cY + imageH / 2);\r\n            blPos = PointPool.instance.borrow(cX - cropW / 2, cY - imageH / 2);\r\n            brPos = PointPool.instance.borrow(cX + cropW / 2, cY - imageH / 2);\r\n        }\r\n        else {\r\n            var imageW = Math.min(h / sourceAspect, w);\r\n            var cropH = imageW * cropAspect;\r\n            tlPos = PointPool.instance.borrow(cX - imageW / 2, cY + cropH / 2);\r\n            trPos = PointPool.instance.borrow(cX + imageW / 2, cY + cropH / 2);\r\n            blPos = PointPool.instance.borrow(cX - imageW / 2, cY - cropH / 2);\r\n            brPos = PointPool.instance.borrow(cX + imageW / 2, cY - cropH / 2);\r\n        }\r\n        center = PointPool.instance.borrow(cX, cY);\r\n        var positions = [tlPos, trPos, blPos, brPos, center];\r\n        return positions;\r\n    };\r\n    ImageCropper.prototype.getCropPositionFromBounds = function (cropPosition) {\r\n        var marginTop = 0;\r\n        var marginLeft = 0;\r\n        var canvasAspect = this.canvasHeight / this.canvasWidth;\r\n        var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n        if (canvasAspect > sourceAspect) {\r\n            marginTop = this.buffer.height / 2 - (this.canvasWidth * sourceAspect) / 2;\r\n        }\r\n        else {\r\n            marginLeft = this.buffer.width / 2 - (this.canvasHeight / sourceAspect) / 2;\r\n        }\r\n        var ratioW = (this.canvasWidth - marginLeft * 2) / this.srcImage.width;\r\n        var ratioH = (this.canvasHeight - marginTop * 2) / this.srcImage.height;\r\n        var actualH = cropPosition.height * ratioH;\r\n        var actualW = cropPosition.width * ratioW;\r\n        var actualX = cropPosition.left * ratioW + marginLeft;\r\n        var actualY = cropPosition.top * ratioH + marginTop;\r\n        if (this.keepAspect) {\r\n            var scaledW = actualH / this.aspectRatio;\r\n            var scaledH = actualW * this.aspectRatio;\r\n            if (this.getCropBounds().height === cropPosition.height) {\r\n                actualH = scaledH;\r\n            }\r\n            else if (this.getCropBounds().width === cropPosition.width) {\r\n                actualW = scaledW;\r\n            }\r\n            else {\r\n                if (Math.abs(scaledH - actualH) < Math.abs(scaledW - actualW)) {\r\n                    actualW = scaledW;\r\n                }\r\n                else {\r\n                    actualH = scaledH;\r\n                }\r\n            }\r\n        }\r\n        var tlPos = PointPool.instance.borrow(actualX, actualY + actualH);\r\n        var trPos = PointPool.instance.borrow(actualX + actualW, actualY + actualH);\r\n        var blPos = PointPool.instance.borrow(actualX, actualY);\r\n        var brPos = PointPool.instance.borrow(actualX + actualW, actualY);\r\n        var center = PointPool.instance.borrow(actualX + actualW / 2, actualY + actualH / 2);\r\n        var positions = [tlPos, trPos, blPos, brPos, center];\r\n        return positions;\r\n    };\r\n    ImageCropper.prototype.getCroppedImageHelper = function (preserveSize, fillWidth, fillHeight) {\r\n        if (this.cropperSettings.cropOnResize) {\r\n            return this.getCroppedImage(preserveSize, fillWidth, fillHeight);\r\n        }\r\n        return this.croppedImage ? this.croppedImage : document.createElement('img');\r\n    };\r\n    // todo: Unused parameters?\r\n    ImageCropper.prototype.getCroppedImage = function (preserveSize, fillWidth, fillHeight) {\r\n        var bounds = this.getBounds();\r\n        if (!this.srcImage) {\r\n            return document.createElement('img');\r\n        }\r\n        else {\r\n            var sourceAspect = this.srcImage.height / this.srcImage.width;\r\n            var canvasAspect = this.canvas.height / this.canvas.width;\r\n            var w = this.canvas.width;\r\n            var h = this.canvas.height;\r\n            if (canvasAspect > sourceAspect) {\r\n                w = this.canvas.width;\r\n                h = this.canvas.width * sourceAspect;\r\n            }\r\n            else {\r\n                if (canvasAspect < sourceAspect) {\r\n                    h = this.canvas.height;\r\n                    w = this.canvas.height / sourceAspect;\r\n                }\r\n                else {\r\n                    h = this.canvas.height;\r\n                    w = this.canvas.width;\r\n                }\r\n            }\r\n            this.ratioW = w / this.srcImage.width;\r\n            this.ratioH = h / this.srcImage.height;\r\n            var offsetH = (this.buffer.height - h) / 2 / this.ratioH;\r\n            var offsetW = (this.buffer.width - w) / 2 / this.ratioW;\r\n            var ctx = this.cropCanvas.getContext('2d');\r\n            if (this.cropperSettings.preserveSize || preserveSize) {\r\n                var width = Math.round(bounds.right / this.ratioW - bounds.left / this.ratioW);\r\n                var height = Math.round(bounds.bottom / this.ratioH - bounds.top / this.ratioH);\r\n                this.cropCanvas.width = width;\r\n                this.cropCanvas.height = height;\r\n                this.cropperSettings.croppedWidth = this.cropCanvas.width;\r\n                this.cropperSettings.croppedHeight = this.cropCanvas.height;\r\n            }\r\n            else {\r\n                this.cropCanvas.width = this.cropWidth;\r\n                this.cropCanvas.height = this.cropHeight;\r\n            }\r\n            ctx.clearRect(0, 0, this.cropCanvas.width, this.cropCanvas.height);\r\n            this.drawImageIOSFix(ctx, this.srcImage, Math.max(Math.round((bounds.left) / this.ratioW - offsetW), 0), Math.max(Math.round(bounds.top / this.ratioH - offsetH), 0), Math.max(Math.round(bounds.width / this.ratioW), 1), Math.max(Math.round(bounds.height / this.ratioH), 1), 0, 0, this.cropCanvas.width, this.cropCanvas.height);\r\n            if (this.cropperSettings.resampleFn) {\r\n                this.cropperSettings.resampleFn(this.cropCanvas);\r\n            }\r\n            this.croppedImage.width = this.cropCanvas.width;\r\n            this.croppedImage.height = this.cropCanvas.height;\r\n            this.croppedImage.src = this.cropCanvas.toDataURL(this.fileType, this.cropperSettings.compressRatio);\r\n            return this.croppedImage;\r\n        }\r\n    };\r\n    ImageCropper.prototype.getBounds = function () {\r\n        var minX = Number.MAX_VALUE;\r\n        var minY = Number.MAX_VALUE;\r\n        var maxX = -Number.MAX_VALUE;\r\n        var maxY = -Number.MAX_VALUE;\r\n        for (var i = 0; i < this.markers.length; i++) {\r\n            var marker = this.markers[i];\r\n            if (marker.position.x < minX) {\r\n                minX = marker.position.x;\r\n            }\r\n            if (marker.position.x > maxX) {\r\n                maxX = marker.position.x;\r\n            }\r\n            if (marker.position.y < minY) {\r\n                minY = marker.position.y;\r\n            }\r\n            if (marker.position.y > maxY) {\r\n                maxY = marker.position.y;\r\n            }\r\n        }\r\n        var bounds = new Bounds();\r\n        bounds.left = minX;\r\n        bounds.right = maxX;\r\n        bounds.top = minY;\r\n        bounds.bottom = maxY;\r\n        return bounds;\r\n    };\r\n    ImageCropper.prototype.setBounds = function (bounds) {\r\n        var topLeft;\r\n        var topRight;\r\n        var bottomLeft;\r\n        var bottomRight;\r\n        var currentBounds = this.getBounds();\r\n        for (var i = 0; i < this.markers.length; i++) {\r\n            var marker = this.markers[i];\r\n            if (marker.position.x === currentBounds.left) {\r\n                if (marker.position.y === currentBounds.top) {\r\n                    marker.setPosition(bounds.left, bounds.top);\r\n                }\r\n                else {\r\n                    marker.setPosition(bounds.left, bounds.bottom);\r\n                }\r\n            }\r\n            else {\r\n                if (marker.position.y === currentBounds.top) {\r\n                    marker.setPosition(bounds.right, bounds.top);\r\n                }\r\n                else {\r\n                    marker.setPosition(bounds.right, bounds.bottom);\r\n                }\r\n            }\r\n        }\r\n        this.center.recalculatePosition(bounds);\r\n        this.center.draw(this.ctx);\r\n        this.draw(this.ctx); // we need to redraw all canvas if we have changed bounds\r\n    };\r\n    ImageCropper.prototype.onTouchMove = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            event.preventDefault();\r\n            if (event.touches.length === 1) {\r\n                for (var i = 0; i < event.touches.length; i++) {\r\n                    var touch = event.touches[i];\r\n                    var touchPosition = ImageCropper.getTouchPos(this.canvas, touch);\r\n                    var cropTouch = new CropTouch(touchPosition.x, touchPosition.y, touch.identifier);\r\n                    PointPool.instance.returnPoint(touchPosition);\r\n                    this.move(cropTouch);\r\n                }\r\n            }\r\n            else {\r\n                if (event.touches.length === 2) {\r\n                    var distance = ((event.touches[0].clientX - event.touches[1].clientX) * (event.touches[0].clientX - event.touches[1].clientX)) + ((event.touches[0].clientY - event.touches[1].clientY) * (event.touches[0].clientY - event.touches[1].clientY));\r\n                    if (this.previousDistance && this.previousDistance !== distance) {\r\n                        var bounds = this.getBounds();\r\n                        if (distance < this.previousDistance) {\r\n                            bounds.top += 1;\r\n                            bounds.left += 1;\r\n                            bounds.right -= 1;\r\n                            bounds.bottom -= 1;\r\n                        }\r\n                        if (distance > this.previousDistance) {\r\n                            if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.top -= 1;\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.top -= 1;\r\n                                bounds.right += 2;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) {\r\n                                bounds.top -= 1;\r\n                                bounds.left -= 2;\r\n                                bounds.bottom += 1;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left !== this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.top -= 2;\r\n                                bounds.left -= 1;\r\n                                bounds.right += 1;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.right += 2;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top === this.minYClamp && bounds.bottom !== this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) {\r\n                                bounds.left -= 2;\r\n                                bounds.bottom += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left === this.minXClamp && bounds.right !== this.maxXClamp) {\r\n                                bounds.top -= 2;\r\n                                bounds.right += 2;\r\n                            }\r\n                            else if (bounds.top !== this.minYClamp && bounds.bottom === this.maxYClamp && bounds.left !== this.minXClamp && bounds.right === this.maxXClamp) {\r\n                                bounds.top -= 2;\r\n                                bounds.left -= 2;\r\n                            }\r\n                        }\r\n                        if (bounds.top < this.minYClamp)\r\n                            bounds.top = this.minYClamp;\r\n                        if (bounds.bottom > this.maxYClamp)\r\n                            bounds.bottom = this.maxYClamp;\r\n                        if (bounds.left < this.minXClamp)\r\n                            bounds.left = this.minXClamp;\r\n                        if (bounds.right > this.maxXClamp)\r\n                            bounds.right = this.maxXClamp;\r\n                        this.setBounds(bounds);\r\n                    }\r\n                    this.previousDistance = distance;\r\n                }\r\n            }\r\n            this.draw(this.ctx);\r\n        }\r\n    };\r\n    ImageCropper.prototype.onMouseMove = function (e) {\r\n        if (this.crop.isImageSet() && this.isMouseDown) {\r\n            var mousePosition = ImageCropper.getMousePos(this.canvas, e);\r\n            this.move(new CropTouch(mousePosition.x, mousePosition.y, 0));\r\n            var dragTouch = this.getDragTouchForID(0);\r\n            if (dragTouch) {\r\n                dragTouch.x = mousePosition.x;\r\n                dragTouch.y = mousePosition.y;\r\n            }\r\n            else {\r\n                dragTouch = new CropTouch(mousePosition.x, mousePosition.y, 0);\r\n            }\r\n            PointPool.instance.returnPoint(mousePosition);\r\n            this.drawCursors(dragTouch);\r\n            this.draw(this.ctx);\r\n        }\r\n    };\r\n    ImageCropper.prototype.move = function (cropTouch) {\r\n        if (this.isMouseDown) {\r\n            this.handleMove(cropTouch);\r\n        }\r\n    };\r\n    ImageCropper.prototype.getDragTouchForID = function (id) {\r\n        for (var i = 0; i < this.currentDragTouches.length; i++) {\r\n            if (id === this.currentDragTouches[i].id) {\r\n                return this.currentDragTouches[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    ImageCropper.prototype.drawCursors = function (cropTouch) {\r\n        var cursorDrawn = false;\r\n        if (cropTouch != null) {\r\n            if (cropTouch.dragHandle === this.center) {\r\n                ImageCropperDataShare.setStyle(this.canvas, 'move');\r\n                cursorDrawn = true;\r\n            }\r\n            if (cropTouch.dragHandle !== null && cropTouch.dragHandle instanceof CornerMarker) {\r\n                this.drawCornerCursor(cropTouch.dragHandle, cropTouch.dragHandle.position.x, cropTouch.dragHandle.position.y);\r\n                cursorDrawn = true;\r\n            }\r\n        }\r\n        var didDraw = false;\r\n        if (!cursorDrawn) {\r\n            for (var i = 0; i < this.markers.length; i++) {\r\n                didDraw = didDraw || this.drawCornerCursor(this.markers[i], cropTouch.x, cropTouch.y);\r\n            }\r\n            if (!didDraw) {\r\n                ImageCropperDataShare.setStyle(this.canvas, 'initial');\r\n            }\r\n        }\r\n        if (!didDraw && !cursorDrawn && this.center.touchInBounds(cropTouch.x, cropTouch.y)) {\r\n            this.center.setOver(true);\r\n            ImageCropperDataShare.setOver(this.canvas);\r\n            ImageCropperDataShare.setStyle(this.canvas, 'move');\r\n        }\r\n        else {\r\n            this.center.setOver(false);\r\n        }\r\n    };\r\n    ImageCropper.prototype.drawCornerCursor = function (marker, x, y) {\r\n        if (marker.touchInBounds(x, y)) {\r\n            marker.setOver(true);\r\n            if (marker.getHorizontalNeighbour().position.x > marker.position.x) {\r\n                if (marker.getVerticalNeighbour().position.y > marker.position.y) {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nwse-resize');\r\n                }\r\n                else {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nesw-resize');\r\n                }\r\n            }\r\n            else {\r\n                if (marker.getVerticalNeighbour().position.y > marker.position.y) {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nesw-resize');\r\n                }\r\n                else {\r\n                    ImageCropperDataShare.setOver(this.canvas);\r\n                    ImageCropperDataShare.setStyle(this.canvas, 'nwse-resize');\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        marker.setOver(false);\r\n        return false;\r\n    };\r\n    // todo: Unused param\r\n    ImageCropper.prototype.onTouchStart = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            this.isMouseDown = true;\r\n        }\r\n    };\r\n    ImageCropper.prototype.onTouchEnd = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            for (var i = 0; i < event.changedTouches.length; i++) {\r\n                var touch = event.changedTouches[i];\r\n                var dragTouch = this.getDragTouchForID(touch.identifier);\r\n                if (dragTouch && dragTouch !== undefined) {\r\n                    if (dragTouch.dragHandle instanceof CornerMarker || dragTouch.dragHandle instanceof DragMarker) {\r\n                        dragTouch.dragHandle.setOver(false);\r\n                    }\r\n                    this.handleRelease(dragTouch);\r\n                }\r\n            }\r\n            if (this.currentDragTouches.length === 0) {\r\n                this.isMouseDown = false;\r\n                this.currentlyInteracting = false;\r\n            }\r\n        }\r\n    };\r\n    // http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\r\n    ImageCropper.prototype.drawImageIOSFix = function (ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n        // Works only if whole image is displayed:\r\n        // ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\r\n        // The following works correct also when only a part of the image is displayed:\r\n        // ctx.drawImage(img, sx * this.vertSquashRatio, sy * this.vertSquashRatio, sw * this.vertSquashRatio, sh *\r\n        // this.vertSquashRatio, dx, dy, dw, dh);\r\n        ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    };\r\n    ImageCropper.prototype.onMouseDown = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            this.isMouseDown = true;\r\n        }\r\n    };\r\n    ImageCropper.prototype.onMouseUp = function (event) {\r\n        if (this.crop.isImageSet()) {\r\n            ImageCropperDataShare.setReleased(this.canvas);\r\n            this.isMouseDown = false;\r\n            this.handleRelease(new CropTouch(0, 0, 0));\r\n        }\r\n    };\r\n    return ImageCropper;\r\n}(ImageCropperModel));\r\nexport { ImageCropper };\r\n//# sourceMappingURL=imageCropper.js.map \r\n",null]}